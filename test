const axios = require("axios");
const { XMLParser } = require("fast-xml-parser");

// ================== CONFIG ==================
const EWS_URL = "https://mail.gadd.gov.sa/EWS/Exchange.asmx";
const EWS_USER = "cal-reader-srv@gadd.gov.sa";
const EWS_PASS = "Gadd@12345";
const EXCHANGE_VERSION = "Exchange2016"; // Exchange2013 / Exchange2016
const TZ_ID = "Arab Standard Time"; // حط القيمة اللي طلعت لك من GetServerTimeZones

// ===========================================

const parser = new XMLParser({
  ignoreAttributes: false,
  attributeNamePrefix: "@_",
  removeNSPrefix: true,
});

function escapeXml(s) {
  return String(s ?? "")
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&apos;");
}

async function ewsPost(soapAction, soapXml) {
  const res = await axios.post(EWS_URL, soapXml, {
    auth: { username: EWS_USER, password: EWS_PASS },
    headers: {
      "Content-Type": "text/xml; charset=utf-8",
      Accept: "text/xml",
      SOAPAction: `"http://schemas.microsoft.com/exchange/services/2006/messages/${soapAction}"`,
    },
    timeout: 30000,
    validateStatus: () => true,
  });

  return res;
}

/**
 * Build SOAP for GetUserAvailability (Host only) with impersonation.
 * Interval 15 minutes. Returns DetailedMerged with MergedFreeBusy string.
 */
function buildGetAvailabilitySoap(hostMailbox, startIso, endIso) {
  return `<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"
  xmlns:t="http://schemas.microsoft.com/exchange/services/2006/types"
  xmlns:m="http://schemas.microsoft.com/exchange/services/2006/messages">
  <soap:Header>
    <t:RequestServerVersion Version="${EXCHANGE_VERSION}" />

    <t:TimeZoneContext>
      <t:TimeZoneDefinition Id="${TZ_ID}" />
    </t:TimeZoneContext>

    <t:ExchangeImpersonation>
      <t:ConnectingSID>
        <t:PrimarySmtpAddress>${escapeXml(hostMailbox)}</t:PrimarySmtpAddress>
      </t:ConnectingSID>
    </t:ExchangeImpersonation>
  </soap:Header>
  <soap:Body>
    <m:GetUserAvailabilityRequest>

      <m:MailboxDataArray>
        <t:MailboxData>
          <t:Email>
            <t:Address>${escapeXml(hostMailbox)}</t:Address>
          </t:Email>
          <t:AttendeeType>Required</t:AttendeeType>
          <t:ExcludeConflicts>false</t:ExcludeConflicts>
        </t:MailboxData>
      </m:MailboxDataArray>

      <t:FreeBusyViewOptions>
        <t:TimeWindow>
          <t:StartTime>${escapeXml(startIso)}</t:StartTime>
          <t:EndTime>${escapeXml(endIso)}</t:EndTime>
        </t:TimeWindow>
        <t:MergedFreeBusyIntervalInMinutes>15</t:MergedFreeBusyIntervalInMinutes>
        <t:RequestedView>DetailedMerged</t:RequestedView>
      </t:FreeBusyViewOptions>

    </m:GetUserAvailabilityRequest>
  </soap:Body>
</soap:Envelope>`;
}


/**
 * Checks if Host time slot is free.
 * Returns { ok:true, free:true/false, merged, reason }
 *
 * MergedFreeBusy characters:
 * 0=Free, 1=Tentative, 2=Busy, 3=OOF, 4=NoData
 * We treat 1/2/3 as conflict.
 */
async function isHostFree(hostMailbox, startIso, endIso) {
  const soap = buildGetAvailabilitySoap(hostMailbox, startIso, endIso);
  const res = await ewsPost("GetUserAvailability", soap);

  if (res.status !== 200) {
    return { ok: false, http: res.status, raw: String(res.data).slice(0, 1200) };
  }

  const data = parser.parse(res.data);

  const fbResponse =
    data.Envelope?.Body?.GetUserAvailabilityResponse?.FreeBusyResponseArray
      ?.FreeBusyResponse;

  // ممكن يكون Array أو Object
  const fb = Array.isArray(fbResponse) ? fbResponse[0] : fbResponse;

  if (!fb) {
    return { ok: false, error: "No FreeBusyResponse returned", raw: String(res.data).slice(0, 1500) };
  }

  // اقرأ رسالة الحالة (مهمة جدًا)
  const respMsg = fb.ResponseMessage;
  const respClass = respMsg?.["@_ResponseClass"];
  const respCode = respMsg?.ResponseCode;
  const msgText = respMsg?.MessageText;

  // إذا فيه خطأ/رفض وصول، ارجعه واضح
  if (respClass && respClass !== "Success") {
    return {
      ok: false,
      error: "GetUserAvailability failed",
      responseClass: respClass,
      responseCode: respCode,
      messageText: msgText,
    };
  }

  // الآن استخرج FreeBusyView
  const view = fb.FreeBusyView;

  // حالات كثيرة: أحيانًا يرجع MergedFreeBusy وأحيانًا يرجع CalendarEventArray فقط
  const merged =
    view?.MergedFreeBusy ??
    view?.MergedFreeBusyString ?? // احتياط لبعض التحويلات
    null;

  // لو ما رجع merged، نقدر نقرر التعارض من CalendarEventArray
  const events = view?.CalendarEventArray?.CalendarEvent
    ? Array.isArray(view.CalendarEventArray.CalendarEvent)
      ? view.CalendarEventArray.CalendarEvent
      : [view.CalendarEventArray.CalendarEvent]
    : [];

  // إذا لا merged ولا events
  if (!merged && events.length === 0) {
    return {
      ok: false,
      error: "No mergedFreeBusy and no CalendarEventArray returned",
      note: "قد يكون الهدف: لا يوجد صلاحية Free/Busy أو تم إرجاع NoData",
      debug: { responseClass: respClass, responseCode: respCode, messageText: msgText },
    };
  }

  // دالة بسيطة لتحديد التعارض من merged
  if (merged) {
    const s = String(merged);
    const hasConflict = [...s].some((c) => c === "1" || c === "2" || c === "3"); // Tentative/Busy/OOF
    return { ok: true, free: !hasConflict, method: "merged", merged: s };
  }

  // بديل: افحص التعارض من الأحداث (CalendarEventArray)
  const start = new Date(startIso).getTime();
  const end = new Date(endIso).getTime();

  // BusyType قد يكون: Free/Tentative/Busy/OOF/NoData
  const conflictEvents = events.filter((ev) => {
    const evStart = new Date(ev.StartTime).getTime();
    const evEnd = new Date(ev.EndTime).getTime();
    const overlaps = evStart < end && evEnd > start;
    const busyType = String(ev.BusyType || "").toLowerCase();
    const isBlocking = ["tentative", "busy", "oof"].includes(busyType);
    return overlaps && isBlocking;
  });

  return {
    ok: true,
    free: conflictEvents.length === 0,
    method: "events",
    conflictCount: conflictEvents.length,
    conflicts: conflictEvents.map((ev) => ({
      start: ev.StartTime,
      end: ev.EndTime,
      busyType: ev.BusyType,
    })),
  };
}


/**
 * Build CreateItem SOAP to create a meeting in Host calendar and send invitations.
 */
function buildCreateMeetingSoap(hostMailbox, meeting) {
  const requiredXml = (meeting.requiredAttendees || [])
    .map((email) =>
      `<t:Attendee><t:Mailbox><t:EmailAddress>${escapeXml(email)}</t:EmailAddress></t:Mailbox></t:Attendee>`
    )
    .join("");

  const optionalXml = (meeting.optionalAttendees || [])
    .map((email) =>
      `<t:Attendee><t:Mailbox><t:EmailAddress>${escapeXml(email)}</t:EmailAddress></t:Mailbox></t:Attendee>`
    )
    .join("");

  return `<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"
  xmlns:t="http://schemas.microsoft.com/exchange/services/2006/types"
  xmlns:m="http://schemas.microsoft.com/exchange/services/2006/messages">
  <soap:Header>
    <t:RequestServerVersion Version="${EXCHANGE_VERSION}" />
    <t:ExchangeImpersonation>
      <t:ConnectingSID>
        <t:PrimarySmtpAddress>${escapeXml(hostMailbox)}</t:PrimarySmtpAddress>
      </t:ConnectingSID>
    </t:ExchangeImpersonation>
  </soap:Header>
  <soap:Body>
    <m:CreateItem SendMeetingInvitations="SendToAllAndSaveCopy">
      <m:SavedItemFolderId>
        <t:DistinguishedFolderId Id="calendar" />
      </m:SavedItemFolderId>
      <m:Items>
        <t:CalendarItem>
          <t:Subject>${escapeXml(meeting.subject)}</t:Subject>
          <t:Body BodyType="HTML">${escapeXml(meeting.bodyHtml)}</t:Body>
          <t:Start>${escapeXml(meeting.startIso)}</t:Start>
          <t:End>${escapeXml(meeting.endIso)}</t:End>
          <t:Location>${escapeXml(meeting.location)}</t:Location>
          ${requiredXml ? `<t:RequiredAttendees>${requiredXml}</t:RequiredAttendees>` : ""}
          ${optionalXml ? `<t:OptionalAttendees>${optionalXml}</t:OptionalAttendees>` : ""}
        </t:CalendarItem>
      </m:Items>
    </m:CreateItem>
  </soap:Body>
</soap:Envelope>`;
}

/**
 * Create meeting only if host is free.
 *
 * Inputs:
 * - hostMailbox: صاحب التقويم
 * - startIso/endIso: لازم تكون ISO مع Offset أو UTC (مثال: 2026-01-25T09:00:00+03:00)
 * - requiredAttendees: array of emails
 *
 * Returns:
 * - {ok:true, created:true, itemId}
 * - {ok:true, created:false, message:"الوقت محجوز"}
 */
async function createMeetingIfHostFree({
  hostMailbox,
  startIso,
  endIso,
  requiredAttendees,
  optionalAttendees = [],
  subject = "Meeting",
  bodyHtml = "",
  location = "",
}) {
  // 1) Check availability (host only)
  const avail = await isHostFree(hostMailbox, startIso, endIso);
  if (!avail.ok) return { ok: false, step: "availability", ...avail };

  if (!avail.free) {
    return {
      ok: true,
      created: false,
      message: "الوقت محجوز لصاحب التقويم",
      details: { mergedFreeBusy: avail.merged, reason: avail.reason },
    };
  }

  // 2) Create meeting
  const soap = buildCreateMeetingSoap(hostMailbox, {
    subject,
    bodyHtml,
    startIso,
    endIso,
    location,
    requiredAttendees,
    optionalAttendees,
  });

  const res = await ewsPost("CreateItem", soap);

  if (res.status !== 200) {
    return { ok: false, step: "create", http: res.status, raw: String(res.data).slice(0, 1500) };
  }

  const data = parser.parse(res.data);

  const msg =
    data.Envelope?.Body?.CreateItemResponse?.ResponseMessages
      ?.CreateItemResponseMessage;

  const responseClass = msg?.["@_ResponseClass"];
  const responseCode = msg?.ResponseCode;

  if (responseClass !== "Success") {
    return { ok: false, step: "create", responseClass, responseCode, raw: String(res.data).slice(0, 1500) };
  }

  const itemId = msg?.Items?.CalendarItem?.ItemId?.["@_Id"];

  return { ok: true, created: true, itemId };
}

function buildFindConflictsSoap(hostMailbox, startIso, endIso) {
  return `<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"
  xmlns:t="http://schemas.microsoft.com/exchange/services/2006/types"
  xmlns:m="http://schemas.microsoft.com/exchange/services/2006/messages">
  <soap:Header>
    <t:RequestServerVersion Version="${EXCHANGE_VERSION}" />
    <t:ExchangeImpersonation>
      <t:ConnectingSID>
        <t:PrimarySmtpAddress>${escapeXml(hostMailbox)}</t:PrimarySmtpAddress>
      </t:ConnectingSID>
    </t:ExchangeImpersonation>
  </soap:Header>
  <soap:Body>
    <m:FindItem Traversal="Shallow">
      <m:ItemShape>
        <t:BaseShape>IdOnly</t:BaseShape>
        <t:AdditionalProperties>
          <t:FieldURI FieldURI="item:Subject"/>
          <t:FieldURI FieldURI="calendar:Start"/>
          <t:FieldURI FieldURI="calendar:End"/>
          <t:FieldURI FieldURI="calendar:LegacyFreeBusyStatus"/>
          <t:FieldURI FieldURI="calendar:IsCancelled"/>
        </t:AdditionalProperties>
      </m:ItemShape>

      <m:CalendarView StartDate="${escapeXml(startIso)}" EndDate="${escapeXml(endIso)}" />

      <m:ParentFolderIds>
        <t:DistinguishedFolderId Id="calendar" />
      </m:ParentFolderIds>
    </m:FindItem>
  </soap:Body>
</soap:Envelope>`;
}

async function hasConflictsByFindItem(hostMailbox, startIso, endIso) {
  const soap = buildFindConflictsSoap(hostMailbox, startIso, endIso);
  const res = await ewsPost("FindItem", soap);

  if (res.status !== 200) {
    return { ok: false, http: res.status, raw: String(res.data).slice(0, 1500) };
  }

  const data = parser.parse(res.data);

  const msg =
    data.Envelope?.Body?.FindItemResponse?.ResponseMessages
      ?.FindItemResponseMessage;

  const responseClass = msg?.["@_ResponseClass"];
  const responseCode = msg?.ResponseCode;

  if (responseClass !== "Success") {
    return { ok: false, responseClass, responseCode, raw: String(res.data).slice(0, 1500) };
  }

  const itemsRaw = msg?.RootFolder?.Items?.CalendarItem;
  const items = itemsRaw
    ? Array.isArray(itemsRaw) ? itemsRaw : [itemsRaw]
    : [];

  // فلترة: تجاهل الملغي (IsCancelled=true)
  const valid = items.filter(it => String(it.IsCancelled || "false") !== "true");

  // إذا وجدت أي عناصر في نفس النافذة → تعارض
  // ملاحظة: CalendarView يرجّع فقط الأحداث اللي تتقاطع مع النافذة عادةً.
  return {
    ok: true,
    conflict: valid.length > 0,
    count: valid.length,
    conflicts: valid.map(it => ({
      subject: it.Subject ?? "",
      start: it.Start ?? null,
      end: it.End ?? null,
      freebusy: it.LegacyFreeBusyStatus ?? "",
    })),
  };
}

async function createMeetingIfFreeByFindItem({
  hostMailbox,
  startIso,
  endIso,
  requiredAttendees,
  optionalAttendees = [],
  subject = "Meeting",
  bodyHtml = "",
  location = "",
}) {
  // 1) تحقق تعارض وقت صاحب التقويم
  const chk = await hasConflictsByFindItem(hostMailbox, startIso, endIso);
  if (!chk.ok) return { ok: false, step: "availability", ...chk };

  if (chk.conflict) {
    return {
      ok: true,
      created: false,
      message: "الوقت محجوز لصاحب التقويم",
      conflictCount: chk.count,
      conflicts: chk.conflicts,
    };
  }

  // 2) إنشاء الاجتماع
  const soap = buildCreateMeetingSoap(hostMailbox, {
    subject,
    bodyHtml,
    startIso,
    endIso,
    location,
    requiredAttendees,
    optionalAttendees,
  });

  const res = await ewsPost("CreateItem", soap);

  if (res.status !== 200) {
    return { ok: false, step: "create", http: res.status, raw: String(res.data).slice(0, 1500) };
  }

  const data = parser.parse(res.data);

  const msg =
    data.Envelope?.Body?.CreateItemResponse?.ResponseMessages
      ?.CreateItemResponseMessage;

  const responseClass = msg?.["@_ResponseClass"];
  const responseCode = msg?.ResponseCode;

  if (responseClass !== "Success") {
    return { ok: false, step: "create", responseClass, responseCode, raw: String(res.data).slice(0, 1500) };
  }

  const itemId = msg?.Items?.CalendarItem?.ItemId?.["@_Id"];
  return { ok: true, created: true, itemId };
}


// ================== Example usage ==================
(async () => {
  const result = await createMeetingIfFreeByFindItem({
    hostMailbox: "nshalwan@gadd.gov.sa",
    startIso: "2026-01-25T09:00:00+03:00",
    endIso: "2026-01-25T10:00:00+03:00",
    requiredAttendees: ["kruwayti@gadd.gov.sa", "mdqahtani@gadd.gov.sa"],
    subject: "اجتماع متابعة",
    bodyHtml: "تفاصيل الاجتماع...",
    location: "Room 1",
  });

  console.log(JSON.stringify(result, null, 2));
})();
